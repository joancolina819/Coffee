/**
 * generated by Xtext 2.12.0
 */
package com.coffee.generator;

import com.coffee.generator.Dialect;
import com.coffee.generator.IGenerator;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;

/**
 * Class autogenerated by xtext and edited to define the code generator
 * for the High Level Variability Language (HLVL)
 * @author Angela Villota
 * @version HLVL 1
 * August 201
 * Updated on January 2019 to the new HLVL grammar
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class HlvlGenerator extends AbstractGenerator {
  private boolean instantiable = false;
  
  private boolean attributes = false;
  
  private IGenerator generator;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    throw new Error("Unresolved compilation problems:"
      + "\nModel cannot be resolved to a type."
      + "\nModel cannot be resolved to a type."
      + "\nThe method modelName(Model) from the type HlvlGenerator refers to the missing type Object"
      + "\nThe method setDialect(Model) from the type HlvlGenerator refers to the missing type Model"
      + "\nThe method toBoolean(Model, String, IFileSystemAccess2) from the type HlvlGenerator refers to the missing type Model"
      + "\nThe method toInteger(Model, String, Dialect) from the type HlvlGenerator refers to the missing type Model"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved");
  }
  
  /**
   * Method to obtain the name of the model
   * @param modes is of type Model
   * @returns String name with the name of the model
   */
  public Object modelName(final /* Model */Object model) {
    throw new Error("Unresolved compilation problems:"
      + "\nname cannot be resolved"
      + "\ntoFirstUpper cannot be resolved");
  }
  
  /**
   * Method that determines the dialect used to specify the model
   * using the
   * @param model is an abstract representation of the model
   */
  public Dialect setDialect(final /* Model */Object model) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method allBoolean(Model) from the type HlvlGenerator refers to the missing type Model"
      + "\nThe method booleanRelations(Model) from the type HlvlGenerator refers to the missing type Model");
  }
  
  /**
   * Method to determine the type of the variables
   * If there are one variable that cannot be mapped into a boolean
   * variable, then the method returns CSP.
   * @param model
   * @return true if all elements are booleans
   */
  public boolean allBoolean(final /* Model */Object model) {
    throw new Error("Unresolved compilation problems:"
      + "\nelements cannot be resolved"
      + "\natt cannot be resolved"
      + "\n=== cannot be resolved"
      + "\n! cannot be resolved"
      + "\ndataType cannot be resolved"
      + "\n== cannot be resolved"
      + "\n|| cannot be resolved"
      + "\ndataType cannot be resolved"
      + "\n== cannot be resolved");
  }
  
  /**
   * Method to determine the type of the constraints
   * If there are one constraint that cannot be mapped into a boolean
   * constraint, then the method returns false.
   * @param model
   * @return true if all constraints can be mapped to boolean
   */
  public boolean booleanRelations(final /* Model */Object model) {
    throw new Error("Unresolved compilation problems:"
      + "\nMultInstantiation cannot be resolved to a type."
      + "\nGroup cannot be resolved to a type."
      + "\nGroup cannot be resolved to a type."
      + "\nGroup cannot be resolved to a type."
      + "\nGroup cannot be resolved to a type."
      + "\nGroup cannot be resolved to a type."
      + "\nrelations cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nmin cannot be resolved"
      + "\nexp cannot be resolved"
      + "\ngetChildren cannot be resolved"
      + "\nvalues cannot be resolved"
      + "\nsize cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nmax cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\n== cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nmax cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\n== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n! cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n! cannot be resolved");
  }
  
  public boolean existInstantiable() {
    return this.instantiable;
  }
  
  public CharSequence toBoolean(final /* Model */Object model, final String modelName, final IFileSystemAccess2 fsa) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method parseModel(Model) from the type IGenerator refers to the missing type Model");
  }
  
  public CharSequence toInteger(final /* Model */Object model, final String modelName, final Dialect dialect) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method parseModel(Model) from the type IGenerator refers to the missing type Model");
  }
  
  public Object PropertieswriteOperationsFile(final Dialect dialect) {
    return null;
  }
}

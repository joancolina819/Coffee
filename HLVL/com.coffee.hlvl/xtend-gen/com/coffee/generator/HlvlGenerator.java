/**
 * generated by Xtext 2.12.0
 */
package com.coffee.generator;

import com.coffee.generator.Dialect;
import com.coffee.generator.IHLVLParser;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 * /
 *  Class autogenerated by xtext and edited to define the code generator
 * for the High Level Variability Language (HLVL)
 * @author Angela Villota
 * @version HLVL 1.4
 * August 2019
 * Updated on January 2019 to the new HLVL grammar
 * Modified on May 2019 for the project refactoring
 */
@SuppressWarnings("all")
public class HlvlGenerator extends AbstractGenerator {
  /**
   * instantiable is a flag for determine if the variability model has multiplicities
   */
  private boolean instantiable = false;
  
  /**
   * attributes is a flag for determine if the variability model has attributes
   */
  private boolean attributes = false;
  
  /**
   * generator is an instance of IGenerator
   */
  private IHLVLParser parser;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    throw new Error("Unresolved compilation problems:"
      + "\nModel cannot be resolved to a type."
      + "\nModel cannot be resolved to a type."
      + "\nThe method parseModel(Model) is undefined for the type IHLVLParser"
      + "\nThe method modelName(Model) from the type HlvlGenerator refers to the missing type Object"
      + "\nThe method findDialect(Model) from the type HlvlGenerator refers to the missing type Model"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved");
  }
  
  /**
   * Method to obtain the name of the model
   * @param modes is of type Model
   * @returns String name with the name of the model
   */
  public Object modelName(final /* Model */Object model) {
    throw new Error("Unresolved compilation problems:"
      + "\nname cannot be resolved"
      + "\ntoFirstUpper cannot be resolved");
  }
  
  /**
   * Method that determines the dialect used to specify the model
   * using the
   * @param model is an abstract representation of the model
   */
  public Dialect findDialect(final /* Model */Object model) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method allElementsBoolean(Model) from the type HlvlGenerator refers to the missing type Model"
      + "\nThe method booleanRelations(Model) from the type HlvlGenerator refers to the missing type Model");
  }
  
  /**
   * Method to determine the type of the variables
   * If there are one variable that cannot be mapped into a boolean
   * variable, then the method returns CSP.
   * @param model
   * @return true if all elements are booleans
   */
  public boolean allElementsBoolean(final /* Model */Object model) {
    throw new Error("Unresolved compilation problems:"
      + "\nelements cannot be resolved"
      + "\natt cannot be resolved"
      + "\n=== cannot be resolved"
      + "\ndataType cannot be resolved"
      + "\n== cannot be resolved"
      + "\n|| cannot be resolved"
      + "\ndataType cannot be resolved"
      + "\n== cannot be resolved"
      + "\n|| cannot be resolved"
      + "\natt cannot be resolved"
      + "\n!== cannot be resolved");
  }
  
  /**
   * Method to determine the type of the constraints
   * If there are one constraint that cannot be mapped into a boolean
   * constraint, then the method returns false.
   * @param model
   * @return true if all constraints can be mapped to boolean
   */
  public boolean booleanRelations(final /* Model */Object model) {
    throw new Error("Unresolved compilation problems:"
      + "\nDecomposition cannot be resolved to a type."
      + "\nDecomposition cannot be resolved to a type."
      + "\nDecomposition cannot be resolved to a type."
      + "\nGroup cannot be resolved to a type."
      + "\nGroup cannot be resolved to a type."
      + "\nGroup cannot be resolved to a type."
      + "\nGroup cannot be resolved to a type."
      + "\nGroup cannot be resolved to a type."
      + "\nrelations cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nmin cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nmax cannot be resolved"
      + "\n== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n== cannot be resolved"
      + "\n! cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n== cannot be resolved"
      + "\n! cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nmin cannot be resolved"
      + "\nexp cannot be resolved"
      + "\ngetChildren cannot be resolved"
      + "\nvalues cannot be resolved"
      + "\nsize cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nmax cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\n== cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nmax cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\n== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n! cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n! cannot be resolved");
  }
  
  public boolean existInstantiable() {
    return this.instantiable;
  }
}
